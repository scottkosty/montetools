% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/monte-carlo.R
\name{mc_run}
\alias{mc_run}
\title{Run a Monte Carlo simulation}
\usage{
mc_run(
  dgp_params = NULL,
  nvec,
  dgp,
  dgpp_to_poi = NULL,
  stat_knowledge = NULL,
  statistics,
  nsims,
  diagnostics = NULL,
  partial_results = NA,
  oloop_is_p = FALSE,
  parallel = NA,
  hooks_pnchunk = hooks_pnchunk_default,
  hooks_ba_dgpp_to_poi = list(),
  seed_initializer = "seed_init_pnhash",
  store_globals = TRUE,
  verbose = 1
)
}
\arguments{
\item{dgp_params}{The data generating process (DGP) parameters. These are the true parameters used to generate the data that are unknown to the statistic. They are either the parameter of interest or the objects that induce it. If a vector is passed to this argument, each element of the vector will be fed to dgp(); if a data.frame is passed, each row will be fed to dgp() as a one-row data.frame (so that it can contain mixed types, as opposed to a vector); if a list is passed, each element will be fed to dgp(). In addition to an element of the corresponding parameter space, the following may be considered part of (i.e., elements in the list) a DGP parameter: the distribution of the explanatory variables, the distribution of the error term, and the functional form (e.g., an R formula object). You do not need to specify this argument if there is only one DGP parameter and dgp() knows everything it needs to. In this special case, your dgp() argument and your dgpp_to_poi() argument should not accept 'dgp_param' as an argument.}

\item{nvec}{The vector of sample sizes.}

\item{dgp}{A function that inputs two arguments: 'dgp_param' (an element of 'dgp_params'); and 'n', the sample size (an element of 'nvec'). It returns one simulated data frame (that will be passed to statistic()).}

\item{dgpp_to_poi}{A function that inputs 'dgp_param' (an element of 'dgp_params'), and outputs the parameter of interest (POI). If the estimator is estimating the DGP param directly, rather than an induced parameter, then it is not necessary to specify this function. If the estimator is estimating a subset of the DGP param (e.g., only one beta value instead of the entire vector of betas), then it is necessary to specify this function. dgpp_to_poi() is called only once per dgp_param, while dgp() is called once per simulation. Often the parameter in the table is different from the "true" parameter that we are trying to perform inference on. For example, the variance of epsilon might be viewed as a parameter. In addition to the DGP parameter, this function may optionally accept a second argument, "maxn", which is essentially max(nvec) and is useful in cases when the true POI is approximated (e.g., using simulation or numeric approximation methods) for deciding the error tolerance of the POI. The return of this function should be a list of length 2, where the first element is the POI value, and the second element is the label corresponding to the POI (and DGP) that should be used for progress messages and subsequently for mc_table() (e.g., the POI table column). For hypothesis testing, this function could just map to "null" or "alternative". This result will just be useful for labelling/sorting really. The diagnostics function for hypothesis tests will not even depend on the true parameter (as opposed to the case where the statistic is an estimator).}

\item{stat_knowledge}{A character vector. Each element of this vector is a name of an element of a dgp_param. Only these names of the dgp param elements will be passed to 'statistic()'. If this argument is specified, 'dgp_params' must be a list object. If the statistic is non-parametric, typically 'stat_knowledge' will either be left as NULL or will be the name of the element of a DGP parameter that just gives the name of the y variable in the data and the name(s) of the x variable(s). For parametric statistics, it's common to pass the functional form or the specification, e.g., an R formula object (which contains the specification but not the true coefficients). See examples.}

\item{statistics}{A statistic is a function that inputs two arguments, 'dataf', which is a data.frame (that is internally produced by calling 'dgp'); and 'dgp_param_shared', which is the subset (determined by 'stat_knowledege') of a 'dgp_params' element that the statistic is allowed to see, and returns either a length-1 numeric of the observed statistic value, or a matrix where each row corresponds to an observed statistic value. For example, if the statistic produces an estimate and a confidence interval, the columns might be "lower", "est", and "upper", and the different rows would be different statistics values that you want to compare (e.g., from different estimators or different ways of bootstrapping to get the confidence interval). A statistic can generally be any function of the data. Examples include p-values, reject/fail-to-reject decisions, and classification predictions. Returning a vector of length k with k > 1 is ambiguous because it is not clear whether it should be interpreted as k different statistics or a single k-dimensional statistic. This argument may be a single statistic, or a list of statistics.}

\item{nsims}{A numeric vector with length equal to 1 or to length(nvec). It may make sense to use a fewer number of simulations for larger number of observations, e.g., (1) if the CPU time is much more and you just want to get an idea of the results; or (2) the variance is lower so don't need to run as many.}

\item{diagnostics}{A diagnostic, or list of diagnostics. For more information, see '?mc_diagnostics'. It is best to specify this argument to mc_run in order to use 'hook_print_partial' (which is used by default) to show intermediate results; and to achieve a self-contained MC object. However, this argument is not strictly necessary if you do not want to use 'hook_print_partial'.}

\item{partial_results}{The file name (or MC object) of previous results (e.g., the partial results file saved with 'hook_save_partial').}

\item{oloop_is_p}{If TRUE, the outer loop of the MC code is over 'dgp_params', and the inner loop is 'nvec'. This argument does not affect the end result but adds convenience for long simulations. If you want to prioritize getting complete results (i.e., for all of 'nvec') for the first few params before the simulations complete, set to TRUE. Alternatively, in many MCs, the larger sample sizes take considerably more time, and are also more likely to fail (e.g., due to longer time and more RAM they take), so if this argument is set to FALSE, then the outer loop will be over 'nvec' and the inner loop will be over 'dgp_params', meaning that you will get results for all parameters for the smaller sample sizes before the simulations get to larger sample sizes.}

\item{parallel}{Can be TRUE/FALSE/NA. If TRUE, montetools will use a reasonable parallelization plan depending on your operating system. If FALSE, montetools will set the future::plan() to 'sequential' (if it isn't already). If NA (default), then montetools does not do any configuration and the future::plan() you manually set before calling mc_run() is used. If you did not manually set one, the likely default is 'sequential'. If montetools changes your plan(), the original plan() will be restored on exit from mc_run().}

\item{hooks_pnchunk}{A list of hooks. These hooks allow the user to customize display of partial results, making pn-pair dependent settings (like having number of cores depend on nobs), etc. See ?mc_hooks.}

\item{hooks_ba_dgpp_to_poi}{This argument is used internally by mc_reproduce() to ensure reproducibility of stochastic 'dgp_to_poi' functions. It is not common for the user to use this hook directly.}

\item{seed_initializer}{Must be one of "seed_init_pnhash", "seed_init_add_ints", or "seed_init_pnhash".}

\item{store_globals}{Whether to capture and store the global objects to make it easier to potentially run mc_reproduce() and mc_extend() later.}

\item{verbose}{An integer (default of 1) to control the level feedback. Set to 0 to turn off messages that are not warnings or errors. At value 1, basic progress information is printed; at values 2 and higher, increasingly more messages are printed that are useful when debugging an unexpected result.}
}
\value{
This function returns a "montecarlo" object, which should then be used with mc_diags() which in turn produces input to mc_table(). Each pn pair correponds to a stacked statistics matrix, which contains all of the observed statistic values across simulations for that pn pair.
}
\description{
Run a Monte Carlo simulation
}
\details{
The following usage example specifies only the essential arguments:

  mc_run(dgp_params, nvec, dgp, dgpp_to_poi, stat_knowledge, statistics, nsims)

After confirming the above passes without error (use nsims = 1 for a quick
test), consider additionally using the 'diagnostics' argument to see results
after each set of simulations is done, and 'parallel = TRUE' to enable
parallelization.

parallel does parallelization over the simulations within each Monte Carlo "column"/chunk
         parLapply is not recommended, but can be useful for debugging (e.g., reports the actual error when there is an error. for mclapply(), hard to figure out what the error was)

progressr is used to provide a progress bar. You can disable the progress bar by running handlers("void") after loading "montetools". Or you can customize the progress bar. For example, 'handlers(handler_progress(format="[:bar] :percent :eta :message"))'. For more information on how to customize the progress bar, or how to enable it even in non-interactive mode, see https://cran.r-project.org/web/packages/progressr/vignettes/progressr-intro.html and https://furrr.futureverse.org/articles/articles/progress.html.
}
\seealso{
[mc_extend()] for increasing the number of simulations of an *existing* 'montecarlo' object, [mc_reproduce()] for reproducing a 'montecarlo' object.
}
